//! Macros for the Twitchchat crate.
//! Currently contains:
//! - `generate_tag_parser_getter`, a macro that generates a getter function for tag traits that optionally also parses its content.

#![deny(
    deprecated_in_future,
    exported_private_dependencies,
    future_incompatible,
    missing_copy_implementations,
    missing_crate_level_docs,
    missing_debug_implementations,
    missing_docs,
    private_in_public,
    rust_2018_compatibility,
    rust_2018_idioms,
    trivial_casts,
    trivial_numeric_casts,
    unsafe_code,
    unused_qualifications,
    trivial_casts,
    trivial_numeric_casts,
    unused_crate_dependencies,
    unused_lifetimes,
    variant_size_differences
)]
#![warn(clippy::pedantic)]

use heck::SnakeCase;
use proc_macro2::{Ident, Span};
use quote::{quote, quote_spanned};
use syn::punctuated::Punctuated;
use syn::{parse_macro_input, Expr, Type};
use syn::{Lit, Token};
use unbox_box::BoxExt as _;
use syn::spanned::Spanned;

#[proc_macro]
/// Generates getters for an IRC tag, optionally parsed as an element of a supplied type. Multiple getters can be generated by supplying multiple arguments separated by commas.
/// Example: `generate_tag_parser_getter!("bits" as u64)` creates a function with signature
/// `fn bits(&self) -> Option<ParsedTag<u64>>` that parses the "bits" token, if possible.
/// Example: `generate_tag_parser_getter!("user-name")` creates a function that returns the value stored in the "user-name" tag, with signature `fn user_name(&self) -> Option<&str>`.
/// # Panics
/// Panics if the token stream cannot be parsed into any expression.
pub fn generate_tag_parser_getter(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let fn_defs: Vec<proc_macro2::TokenStream> = parse_macro_input!(input with Punctuated::<Expr, Token![,]>::parse_terminated) // items are separated by commas
        .iter()
        .map::<proc_macro2::TokenStream, _>(|syntax_branch| {
            if let Expr::Lit(expr_lit) = syntax_branch {
                // case 1: argument is exactly one literal, and we produce a simple getter function
                generate_getter(expr_lit)
            } else if let Expr::Cast(assignment) = syntax_branch {
                // case 2: argument involves a conversion, and we produce a parsing function
                generate_parser(assignment)
            } else {
                // using quote_spanned while throwing an error lets us specify which part of the expression should be underlined red
                quote_spanned!(syntax_branch.span()=> compile_error!("Invalid argument syntax. Arguments can have the form `<Tag Index String Literal>` or `<Tag Index String Literal> as <Type>`."))
            }
        })
        .collect();
    quote!(
        #(#fn_defs)*
    )
    .into()
}

/// Takes an individual argument that must only consist of one String literal, and returns the corresponding getter function.
fn generate_getter(expr_lit: &syn::ExprLit) -> proc_macro2::TokenStream {
    if let Lit::Str(tag_index) = &expr_lit.lit {
        //argument is exactly one literal
        let fn_name = Ident::new(&tag_index.value().to_snake_case(), Span::call_site());
        quote! (
            fn #fn_name(&self) -> std::option::Option<&'a str>{
                self.tags().get(#tag_index)
            }
        )
    } else {
        // using quote_spanned while throwing an error lets us specify which part of the expression should be underlined red
        quote_spanned!(expr_lit.span()=> compile_error!("Each argument has to begin with a string literal specifying the tag index."))
    }
}

/// Takes an individual argument that consists of an assignment with 'as', and returns the corresponding parser function.
fn generate_parser(assignment: &syn::ExprCast) -> proc_macro2::TokenStream {
    // destructure assignment as Expr::Lit
    let expr: &syn::ExprLit = match assignment.expr.unbox_ref() {
        Expr::Lit(x) => x,
        // using quote_spanned while throwing an error lets us specify which part of the expression should be underlined red
        _ => return quote_spanned!(assignment.span()=> compile_error!("Each argument has to begin with a string literal specifying the tag index.")),
    };

    // destructure expr as Lit::Str
    let tag_index: &syn::LitStr = match &expr.lit {
        Lit::Str(x) => x,
        _ => return quote_spanned!(expr.span()=> compile_error!("Each argument has to begin with a string literal specifying the tag index.")),
    };

    let parsed_type: Type = *assignment.ty.clone();
    let fn_name = Ident::new(&tag_index.value().to_snake_case(), Span::call_site());

    quote! (
        fn #fn_name(&self) -> std::option::Option<crate::irc::tags::ParsedTag<#parsed_type>>{
            self.tags().get_parsed(#tag_index)
        }
    )
}
