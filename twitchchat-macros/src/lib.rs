//! Macros for the Twitchchat crate.
//! Currently contains:
//! - `generate_tag_parser_getter`, a macro that generates a getter function for tag traits that optionally also parses its content.
//! - `irc_tags`, an attribute macro that implements the tags for a specific struct.

#![deny(
    deprecated_in_future,
    exported_private_dependencies,
    future_incompatible,
    missing_copy_implementations,
    missing_crate_level_docs,
    missing_debug_implementations,
    missing_docs,
    private_in_public,
    rust_2018_compatibility,
    rust_2018_idioms,
    trivial_casts,
    trivial_numeric_casts,
    unsafe_code,
    unused_qualifications,
    trivial_casts,
    trivial_numeric_casts,
    unused_crate_dependencies,
    unused_lifetimes,
    variant_size_differences
)]
#![warn(clippy::pedantic)]

use heck::{CamelCase, SnakeCase};
use proc_macro2::{Ident, Span};
use quote::{quote, quote_spanned};
use syn::punctuated::Punctuated;
use syn::spanned::Spanned;
use syn::{parse_macro_input, Expr, Type};
use syn::{Lit, Token};
use unbox_box::BoxExt as _;

#[proc_macro]
/// Generates traits that contain a getter for an IRC tag, optionally parsed as an element of a supplied type. Multiple traits can be generated by supplying multiple arguments separated by commas.
/// Example: `generate_tag_parser_getter!("bits" as u64)` creates a trait `HasBitsTag<'a>` that includes a method with signature
/// `fn bits(&self) -> Option<ParsedTag<u64>>` that parses the "bits" token, if possible.
/// Example: `generate_tag_parser_getter!("user-name")` creates a trait `HasUserNameTag` that includes a method that returns the value stored in the "user-name" tag, with signature `fn user_name(&self) -> Option<&str>`.
/// # Panics
/// Panics if the token stream cannot be parsed into any expression.
pub fn generate_tag_traits(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let trait_defs: Vec<proc_macro2::TokenStream> = parse_macro_input!(input with Punctuated::<Expr, Token![,]>::parse_terminated) // items are separated by commas
        .iter()
        .map::<proc_macro2::TokenStream, _>(|syntax_branch| {
            if let Expr::Lit(expr_lit) = syntax_branch {
                // case 1: argument is exactly one literal, and we produce a trait including a simple getter method
                generate_getter_trait(expr_lit)
            } else if let Expr::Cast(assignment) = syntax_branch {
                // case 2: argument involves a conversion, and we produce a trait including a parsing method
                generate_parser_trait(assignment)
            } else {
                // using quote_spanned while throwing an error lets us specify which part of the expression should be underlined red
                quote_spanned!(syntax_branch.span()=> compile_error!("Invalid argument syntax. Arguments can have the form `<Tag Index String Literal>` or `<Tag Index String Literal> as <Type>`."))
            }
        })
        .collect();
    quote!(
        #(#trait_defs)*
    )
    .into()
}

/// Just a quick helper method to turn Strings into `proc_macro2::Ident`.
trait ToIdent: AsRef<str> {
    fn to_ident(&self) -> Ident {
        quote::format_ident!("r#{}", Ident::new(self.as_ref(), Span::call_site()))
    }
}
impl ToIdent for String {}

/// Transforms a tag name into the name of an associated trait.
fn trait_name_from_tag_index(tag_index: &syn::LitStr) -> Ident {
    format!("has_{}_tag", tag_index.value())
        .to_camel_case()
        .to_ident()
}

/// Takes a `TokenStream` for a parser or getter function function and wraps it in a trait.
fn wrap_in_trait(
    fn_stream: &proc_macro2::TokenStream,
    tag_index: &syn::LitStr,
) -> proc_macro2::TokenStream {
    let trait_name = trait_name_from_tag_index(tag_index);
    let doc = syn::LitStr::new(&format!(r#"Supplies a method to return values held by the tag "{}"."#, tag_index.value()), Span::call_site());
    quote!(
        #[doc=#doc]
        pub trait #trait_name<'a>: HasTags<'a> {
            #fn_stream
        }
    )
}

/// Takes an individual argument that must only consist of one String literal, and returns the corresponding getter function.
fn generate_getter_trait(expr_lit: &syn::ExprLit) -> proc_macro2::TokenStream {
    if let Lit::Str(tag_index) = &expr_lit.lit {
        //argument is exactly one literal
        let fn_name = tag_index.value().to_snake_case().to_ident();
        let fn_stream = quote! (
            fn #fn_name(&'a self) -> std::option::Option<&'a str>{
                self.tags().get(#tag_index)
            }
        );
        wrap_in_trait(&fn_stream, tag_index)
    } else {
        // using quote_spanned while throwing an error lets us specify which part of the expression should be underlined red
        quote_spanned!(expr_lit.span()=> compile_error!("Each argument has to begin with a string literal specifying the tag index."))
    }
}

/// Takes an individual argument that consists of an assignment with 'as', and returns the corresponding parser function.
fn generate_parser_trait(assignment: &syn::ExprCast) -> proc_macro2::TokenStream {
    // destructure assignment as Expr::Lit
    let expr: &syn::ExprLit = match assignment.expr.unbox_ref() {
        Expr::Lit(x) => x,
        // using quote_spanned while throwing an error lets us specify which part of the expression should be underlined red
        _ => {
            return quote_spanned!(assignment.span()=> compile_error!("Each argument has to begin with a string literal specifying the tag index."))
        }
    };

    // destructure expr as Lit::Str
    let tag_index: &syn::LitStr = match &expr.lit {
        Lit::Str(x) => x,
        _ => {
            return quote_spanned!(expr.span()=> compile_error!("Each argument has to begin with a string literal specifying the tag index."))
        }
    };

    let parsed_type: Type = *assignment.ty.clone();
    let fn_name = tag_index.value().to_snake_case().to_ident();

    let fn_stream = quote! (
        fn #fn_name(&'a self) -> std::option::Option<crate::irc::tags::ParsedTag<#parsed_type>>{
            self.tags().get_parsed(#tag_index)
        }
    );

    wrap_in_trait(&fn_stream, tag_index)
}

/// Derives a `syn::LitStr` element from a `syn::Expr`, or returns an appropriate compiler error if the expression does not match the `LitStr` pattern.
fn lit_str_from_tag_expr(tag_expr: &Expr) -> Result<&syn::LitStr, proc_macro2::TokenStream> {
    // destructure tag_expr as Expr::Lit
    let expr_lit: &syn::ExprLit = match tag_expr {
        Expr::Lit(x) => x,
        _ => {
            return Err(
                quote_spanned!(tag_expr.span() => compile_error!("Arguments of irc_tags attribute have to be string literals.")),
            )
        }
    };

    // destructure expr_lit as Lit::Str
    let lit_str: &syn::LitStr = match &expr_lit.lit {
        Lit::Str(x) => x,
        _ => {
            return Err(
                quote_spanned!(tag_expr.span() => compile_error!("Arguments of irc_tags attribute have to be string literals.")),
            )
        }
    };

    Ok(lit_str)
}

#[proc_macro_attribute]
/// Implements tags for an associated struct. Only tags initialized with `generate_tag_traits` can be implemented.
pub fn irc_tags(
    attr: proc_macro::TokenStream,
    item: proc_macro::TokenStream,
) -> proc_macro::TokenStream {
    // parse attribute into list of tags
    let tags = parse_macro_input!(attr with Punctuated::<Expr, Token![,]>::parse_terminated);

    // get name of the struct that the tags will be added to
    let struct_def = item.clone();
    let message_struct = parse_macro_input!(struct_def as syn::ItemStruct);
    let struct_ident = message_struct.ident;

    // Implement trait for each argument
    let trait_impls: Vec<proc_macro2::TokenStream> = match tags
        .iter()
        .map(lit_str_from_tag_expr)
        .collect::<Result<Vec<_>, _>>()
    {
        Ok(lit_str_vec) => lit_str_vec
            .into_iter()
            .map(trait_name_from_tag_index)
            .map(|tag_trait| {
                // importing each trait individually should give us better error messages if a tag was inserted that does not exist
                // we import the trait under a different name so that there aren't any conflicting definitions with already defined traits
                let safe_tag_trait = quote::format_ident!("__Macro{}", tag_trait);
                quote!(
                        use crate::messages::tags::#tag_trait as #safe_tag_trait;
                        impl<'a> #safe_tag_trait<'a> for #struct_ident<'a> {}
                )
            })
            .collect(),
        Err(err_msg) => return err_msg.into(),
    };

    // add implementation of all necessary traits after struct definition
    let struct_def: proc_macro2::TokenStream = item.into();
    quote!(
        #struct_def

        #(#trait_impls)*
    )
    .into()
}
